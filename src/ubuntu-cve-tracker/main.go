// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.
//
// Contributor:
// - Aaron Meihm ameihm@mozilla.com

// Generate scribe policy checks using data in the Ubuntu CVE tracker
// repository.
package main

import (
	"bufio"
	"encoding/xml"
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"oval"
	"path"
	"regexp"
	"strings"
	"unicode"
)

type distPatchInfo map[string]string

type cveEntry struct {
	cveID  string
	pkgMap map[string]distPatchInfo
}

type releaseInformation struct {
	identifier string
	lsbmatch   string
	defid      string
}

var releaseList = []releaseInformation{
	{"utopic", "14.10", ""},
	{"vivid", "15.04", ""},
	{"trusty", "14.04", ""},
	{"precise", "12.04", ""},
	{"lucid", "10.04", ""},
}

var entries []cveEntry
var matchFilter *regexp.Regexp

// The hackTranslate* functions perform conversion on name and version
// strings if the package name is either "linux" or begins with "linux-". If
// this is the case, linux in the package name is translated to be
// "linux-image-generic". Additionally, the upload revision element if
// present in the version string is removed. This allows a comparison of
// the version to occur against a known package name (linux-image-generic),
// instead of requiring resolution of whatever the most recent installed
// kernel image package is which will be named linux-image-<ver>-generic.
func hackTranslateName(pkgname string) string {
	if pkgname != "linux" && !strings.HasPrefix(pkgname, "linux-") {
		return pkgname
	}
	return strings.Replace(pkgname, "linux", "linux-image-generic", 1)
}

func hackTranslateVersion(pkgname string, ver string) string {
	if !strings.HasPrefix(pkgname, "linux-image-generic") {
		return ver
	}

	ffunc := func(c rune) bool {
		if c == '-' {
			return true
		}
		return false
	}
	f := strings.FieldsFunc(ver, ffunc)
	if len(f) != 2 {
		return ver
	}
	ret := f[1]
	idx := strings.Index(ret, ".")
	if idx == -1 {
		return ver
	}
	idx2 := idx + 1
	for _, c := range ret[idx2:] {
		if !unicode.IsDigit(c) {
			break
		}
		idx2++
	}
	ret = f[0] + "." + ret[:idx] + ret[idx2:]

	return ret
}

func addReleaseDefinition(o *oval.GOvalDefinitions, rinfo *releaseInformation) {
	identifier := fmt.Sprintf("reldef-%v", rinfo.identifier)
	rinfo.defid = identifier

	obj := oval.GTFC54Obj{}
	obj.ID = identifier + "-object"
	obj.Path = "/etc"
	obj.Filename = "lsb-release"
	obj.Pattern = "^.*Ubuntu.*\\nDISTRIB_RELEASE=(\\d{1,2}\\.\\d{1,2})"

	state := oval.GTFC54State{}
	state.ID = identifier + "-state"
	state.SubExpression = rinfo.lsbmatch

	test := oval.GTFC54Test{}
	test.ID = identifier + "-test"
	test.Object.ObjectRef = obj.ID
	test.State.StateRef = state.ID

	def := oval.GDefinition{}
	def.ID = identifier
	def.Class = "inventory"
	def.Metadata.Title = fmt.Sprintf("release check for %v", identifier)

	criterion := oval.GCriterion{}
	criterion.Test = test.ID
	def.Criteria.Operator = "AND"
	def.Criteria.Criterion = append(def.Criteria.Criterion, criterion)

	o.Definitions.Definitions = append(o.Definitions.Definitions, def)
	o.Tests.TFC54Tests = append(o.Tests.TFC54Tests, test)
	o.Objects.TFC54Objects = append(o.Objects.TFC54Objects, obj)
	o.States.TFC54States = append(o.States.TFC54States, state)
}

func addReleaseDefinitions(o *oval.GOvalDefinitions) {
	for x := range releaseList {
		addReleaseDefinition(o, &releaseList[x])
	}
}

func getReleaseDefinition(dist string) string {
	for _, x := range releaseList {
		if dist == x.identifier {
			return x.defid
		}
	}
	return ""
}

func parseEntryFile(fpath string) (ret cveEntry) {
	const (
		_ = iota
		INNER_NONE
		INNER_PATCH
	)
	fd, err := os.Open(fpath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "%v\n", err)
		os.Exit(1)
	}
	defer func() {
		fd.Close()
	}()

	scanner := bufio.NewScanner(fd)
	parserMode := INNER_NONE
	curPkgName := ""
	ret.cveID = path.Base(fpath)
	ret.pkgMap = make(map[string]distPatchInfo)
	for scanner.Scan() {
		tokens := strings.Fields(scanner.Text())
		if len(tokens) == 0 {
			parserMode = INNER_NONE
			curPkgName = ""
			continue
		}

		if strings.HasPrefix(tokens[0], "Patches_") {
			parserMode = INNER_PATCH
			curPkgName = strings.TrimPrefix(tokens[0], "Patches_")
			curPkgName = strings.TrimRight(curPkgName, ":")
			curPkgName = hackTranslateName(curPkgName)
			ret.pkgMap[curPkgName] = make(map[string]string)
			continue
		}

		if parserMode == INNER_PATCH {
			if len(tokens) < 2 {
				continue
			}
			idx := strings.Index(tokens[0], "_")
			if idx == -1 {
				continue
			}
			distname := tokens[0][:idx]
			if tokens[1] == "released" && len(tokens) > 2 {
				patchver := tokens[2]
				patchver = strings.Trim(patchver, "()")
				patchver = hackTranslateVersion(curPkgName, patchver)
				ret.pkgMap[curPkgName][distname] = patchver
			}
		}
	}
	if err = scanner.Err(); err != nil {
		fmt.Fprintf(os.Stderr, "%v\n", err)
		os.Exit(1)
	}

	return
}

func loadEntries(dirpath string) {
	dirents, err := ioutil.ReadDir(dirpath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "%v\n", err)
		os.Exit(1)
	}
	for _, i := range dirents {
		if !strings.HasPrefix(i.Name(), "CVE-") {
			continue
		}
		if matchFilter != nil {
			if !matchFilter.MatchString(i.Name()) {
				continue
			}
		}
		fname := path.Join(dirpath, i.Name())
		entries = append(entries, parseEntryFile(fname))
	}
}

func addDefinition(o *oval.GOvalDefinitions, prefix string, pkgname string, dist string, cve cveEntry) {
	// Don't create a definition for anything that is not in our release
	// list.
	reldefid := getReleaseDefinition(dist)
	if reldefid == "" {
		return
	}

	// Create a state
	stateid := fmt.Sprintf("%v-state", prefix)
	state := oval.GDPKGInfoState{}
	state.ID = stateid
	state.EVRCheck.DataType = "evr_string"
	state.EVRCheck.Operation = "less than"
	state.EVRCheck.Value = cve.pkgMap[pkgname][dist]

	// Create an object definition for the package
	objid := fmt.Sprintf("%v-object", prefix)
	obj := oval.GDPKGInfoObj{}
	obj.Name = pkgname
	obj.ID = objid

	// Create a test
	testid := fmt.Sprintf("%v-test", prefix)
	test := oval.GDPKGInfoTest{}
	test.ID = testid
	test.Object.ObjectRef = objid
	test.State.StateRef = stateid

	// Extend definition for release criteria
	exdef := oval.GExtendDefinition{}
	exdef.Test = reldefid
	exdef.Comment = "associated release definition"

	// Create the new definition
	def := oval.GDefinition{}
	def.ID = prefix
	def.Class = "patch"
	def.Metadata.Title = fmt.Sprintf("%v (%v) test for %v", cve.cveID, pkgname, dist)

	criterion := oval.GCriterion{}
	criterion.Test = testid
	def.Criteria.Operator = "AND"
	def.Criteria.Criterion = append(def.Criteria.Criterion, criterion)
	def.Criteria.ExtendDef = append(def.Criteria.ExtendDef, exdef)

	o.Definitions.Definitions = append(o.Definitions.Definitions, def)
	o.States.DPKGInfoStates = append(o.States.DPKGInfoStates, state)
	o.Objects.DPKGInfoObjects = append(o.Objects.DPKGInfoObjects, obj)
	o.Tests.DPKGInfoTests = append(o.Tests.DPKGInfoTests, test)
}

func processEntries() {
	root := oval.GOvalDefinitions{}

	addReleaseDefinitions(&root)

	for i, ent := range entries {
		for x := range ent.pkgMap {
			for y := range ent.pkgMap[x] {
				prefix := fmt.Sprintf("ubuntu-%v-%v-%v", i, x, y)
				addDefinition(&root, prefix, x, y, ent)
			}
		}
	}

	enc := xml.NewEncoder(os.Stdout)
	enc.Indent("", "  ")
	if err := enc.Encode(root); err != nil {
		fmt.Fprintf(os.Stderr, "%v\n", err)
		os.Exit(1)
	}
}

func main() {
	var fMatch string

	flag.StringVar(&fMatch, "i", "", "filter regexp")
	flag.Parse()
	args := flag.Args()
	if len(args) < 1 {
		fmt.Fprintf(os.Stderr, "specify path to ubuntu-cve-tracker directory\n")
		os.Exit(1)
	}

	fm, err := regexp.Compile(fMatch)
	if err != nil {
		fmt.Fprintf(os.Stderr, "%v\n", err)
		os.Exit(1)
	}
	matchFilter = fm

	entries = make([]cveEntry, 0)

	procdir := path.Join(args[0], "active")
	loadEntries(procdir)
	procdir = path.Join(args[0], "retired")
	loadEntries(procdir)
	processEntries()
}
